{% extends "geomap/base.html" %}
{% load static %}

{% block content %}
<script type="module">
    const TILE_SIZE = 256;
    const zoomLevel = 14;
    const tx = [ 0, 1, 1, 0, -1, -1, -1, 0, 1 ], ty = [ 0, 0, 1, 1, 1, 0, -1, -1, -1 ];
    let scene, camera, renderer;
    let controls;
    let mapDataList = new Array(9);
    let location = { latitude: 34.686856, longtitude: 135.522961 };

    window.addEventListener("resize", function() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
    }, false);

    window.addEventListener("load", function() {
        //getLocation();
        init();
        animate();
    });

    function getLocation() {
        navigator.geolocation.getCurrentPosition(function( position ) {
            const lat = position.coords.latitude;
            const lng = position.coords.longitude;
            location = { latitude: lat, longtitude: lng };
        });
    }

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 1000 );
        camera.position.set(0, 800, 0);
        camera.lookAt(0, 0, 0);
        scene.add( camera );

        renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );
        
        document.body.appendChild( renderer.domElement );

        const axes = new THREE.AxesHelper( 600 );
        scene.add( axes );

        setController();

        const tileCoordinate = getTileCoordinate( zoomLevel, location.latitude, location.longtitude );
        console.log(tileCoordinate);
        for(let i = 0; i < 9; i++) {
            const x = parseInt( tileCoordinate.x ) + tx[i];
            const y = parseInt( tileCoordinate.y ) + ty[i];
            loadData( i, zoomLevel, x, y );
        }
    }

    function setController() {
        document.addEventListener("touchmove", function(e) { e.preventDefault(); }, { passive:false });
        controls = new THREE.OrbitControls( camera, renderer.domElement );
        controls.target.set( 0, 0, 0 );
        controls.enableDamping = true;
        controls.dampingFactor = 0.5;
        controls.enableZoom = false;
    }
    
    function getTileCoordinate( z, lat, lng ) {
        const L = 85.05112878;
        const pixelCoordinate = {
            x: TILE_SIZE * Math.pow(2, z) * ( ( lng + 180 ) / 360 ),
            y: TILE_SIZE * Math.pow(2, z) / ( 2 * Math.PI ) * ( - Math.atanh( Math.sin( Math.PI / 180 * lat )) + Math.atanh( Math.sin( Math.PI / 180 * L ) ) )
        };
        const tileCoordinate = {
            x: pixelCoordinate.x / TILE_SIZE,
            y: pixelCoordinate.y / TILE_SIZE
        };

        return tileCoordinate;
    }

    function loadData( tileNum, z, x, y ) {
        let req = new XMLHttpRequest();
        req.open( "GET", `https://cyberjapandata.gsi.go.jp/xyz/dem/${z}/${x}/${y}.txt` );
        req.send();
        	
        req.onload = function() {
            let row = req.responseText.split("\n");

            mapDataList[tileNum] = new Array(TILE_SIZE);
            for(let i = 0; i < TILE_SIZE; i++) {
                mapDataList[tileNum][i] = row[i].split(",");
            }
            
            const imageUrl = `https://cyberjapandata.gsi.go.jp/xyz/std/${z}/${x}/${y}.png`
            drawMap( tileNum, mapDataList[tileNum], imageUrl );
        }
    }

    function drawMap( tileNum, mapData, imageUrl ) {
        let geometry = new THREE.BufferGeometry();
        const itemSize = 3
        let vertices = new Float32Array( (TILE_SIZE - 1) * (TILE_SIZE - 1) * 2 * 3 * itemSize );
        const dx = [[ 0, 1, 1 ], [ 0, 0, 1 ]], dy = [[ 0, 1, 0 ], [ 0, 1, 1 ]];

        let step = 0;
        for(let y = 0; y < TILE_SIZE - 1; y++) {
            for(let x = 0; x < TILE_SIZE - 1; x++) {
                for(let i = 0; i < 2; i++) {
                    for(let j = 0; j < 3; j++) {
                        let z = mapData[ y + dy[i][j] ][ x + dx[i][j] ];
                        vertices[ step ] = x + dx[i][j];
                        vertices[ step + 1 ] = y + dy[i][j];
                        vertices[ step + 2 ] = - z;
                        step += 3;
                    }
                }
            }
        }
        geometry.setAttribute( "position", new THREE.BufferAttribute( vertices, itemSize ) );
        geometry.computeVertexNormals ();

        const texture = new THREE.TextureLoader().load( imageUrl );
        const material = new THREE.MeshBasicMaterial({
            map: texture
        });

        const mesh = new THREE.Mesh( geometry, new THREE.MeshNormalMaterial() );
        mesh.position.set( ( - 0.5 + tx[tileNum] ) * TILE_SIZE, 0, ( - 0.5 + ty[tileNum] ) * TILE_SIZE );
        mesh.rotation.set( 90 / 180 * Math.PI, 0, 0 );

        scene.add(mesh);
    }

    function animate() {
        if(controls){
            controls.update();
        }
        
        renderer.render( scene, camera );
        requestAnimationFrame( animate );
    };
</script>
{% endblock %}