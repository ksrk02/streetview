{% extends "geomap/base.html" %}
{% load static %}

{% block content %}
<div id="status-window">
    <lable>Zoom Level:</lable>
    <input id="zoom-level" type="number" placeholder="5~14" value="14" min="5" max="14" step="1">
    <lable>Scale:</lable>
    <input id="change-scale" type="number" placeholder="-5~0" value="0" min="-5" max="0" step="1">
    <button id="get-location" type="button">Get Location</button>
</div>

<script type="module">

    document.getElementById( "zoom-level" ).addEventListener( "change", function(e) {

        zoomLevel = document.getElementById( "zoom-level" ).value;
        if ( zoomLevel > 14 ) zoomLevel = 14;
        if ( zoomLevel < 5 ) zoomLevel = 5;
        
        while(mapGroup.children.length > 0){ 
            mapGroup.remove( mapGroup.children[0] );
        }
        
        scene.remove( mapGroup );

        start();
        animate();
    });


    document.getElementById( "get-location" ).addEventListener( "click", function(e) {
        getLocation();
        start();
        animate();
    });


    document.getElementById( "change-scale" ).addEventListener( "change", function(e) {

        const ratio = Math.pow( 10, document.getElementById( "change-scale" ).value - scale );

        for ( let tileNum = 0; tileNum < mapGroup.children.length; tileNum++ ) {
            
            let vertices = mapGroup.children[ tileNum ].geometry.attributes.position.array;

            for ( let y = 0; y < TILE_SIZE - 1; y++ ) {
                for ( let x = 0; x < TILE_SIZE - 1; x++ ) {
                    for ( let i = 0; i < 2; i++ ) {
                        for ( let j = 0; j < 3; j++ ) {

                            vertices[ ((( y * ( TILE_SIZE - 1 ) + x ) * 2 + i ) * 3 + j) * 3 + 2 ] *= ratio;
                        }
                    }
                }
            }

            mapGroup.children[ tileNum ].geometry.attributes.position.needsUpdate = true;
        }

        scale = document.getElementById( "change-scale" ).value;
    });



    //three.js

    const TILE_SIZE = 256;
    const t = [
            { x: 0, y: 0 },
            { x: 1, y: 0 }, { x: 1, y: 1 }, { x: 0, y: 1 }, { x: -1, y: 1 }, 
            { x: -1, y: 0 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
            { x: 2, y: 0 }, { x: 2, y: 1 }, { x: 2, y: 2 }, { x: 1, y: 2 }, 
            { x: 0, y: 2 }, { x: -1, y: 2 }, { x: -2, y: 2 }, { x: -2, y: 1 },
            { x: -2, y: 0 }, { x: -2, y: -1 }, { x: -2, y: -2 }, { x: -1, y: -2 }, 
            { x: 0, y: -2 }, { x: 1, y: -2 }, { x: 2, y: -2 }, { x: 2, y: -1 },
        ];
    let zoomLevel = 14;

    let scene;
    let camera;
    let renderer;
    let controls;
    let mapDataList = new Array(9);
    let mapGroup = new THREE.Group();
    var location;
    let scale = 0;


    window.addEventListener("resize", function() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }, false);


    window.addEventListener("load", function() {
        init();
        start();
        animate();
    });


    function init() {

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 10000 );
        camera.position.set(0, 1200, 0);
        camera.lookAt(0, 0, 0);
        scene.add( camera );

        renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );
        
        document.body.appendChild( renderer.domElement );

        zoomLevel = document.getElementById("zoom-level").value;
        console.log(zoomLevel);

        location = { latitude: 35.6851, longtitude: 139.7528 };

        setController();
    }


    function setController() {

        document.addEventListener("touchmove", function(e) { e.preventDefault(); }, { passive:false });

        controls = new THREE.OrbitControls( camera, renderer.domElement );

        controls.target.set( 0, 0, 0 );
        controls.enableDamping = true;
        controls.dampingFactor = 0.5;
        controls.enableZoom = true;
    }


    function getLocation() {

        navigator.geolocation.getCurrentPosition(function( position ) {
            const lat = position.coords.latitude;
            const lng = position.coords.longitude;
            location = { latitude: lat, longtitude: lng };
            console.log(location);
        });
    }


    function start() {

        while ( mapGroup.children.length > 0 ) { 
            mapGroup.remove( mapGroup.children[0] );
        }

        console.log(location);

        const tileCoordinate = getTileCoordinate( zoomLevel, location.latitude, location.longtitude );

        for(let i = 0; i < t.length; i++) {
            const x = parseInt( tileCoordinate.x ) + t[i].x;
            const y = parseInt( tileCoordinate.y ) + t[i].y;
            loadData( i, zoomLevel, x, y );
        }

        scene.add( mapGroup );
    }


    function getTileCoordinate( z, lat, lng ) {

        const L = 85.05112878;
        const pixelCoordinate = {
            x: TILE_SIZE * Math.pow(2, z) * ( ( lng + 180 ) / 360 ),
            y: TILE_SIZE * Math.pow(2, z) / ( 2 * Math.PI ) * ( - Math.atanh( Math.sin( Math.PI / 180 * lat )) + Math.atanh( Math.sin( Math.PI / 180 * L ) ) )
        };

        const tileCoordinate = {
            x: pixelCoordinate.x / TILE_SIZE,
            y: pixelCoordinate.y / TILE_SIZE
        };

        return tileCoordinate;
    }


    function loadData( tileNum, z, x, y ) {

        let req = new XMLHttpRequest();
        req.open( "GET", `https://cyberjapandata.gsi.go.jp/xyz/dem/${z}/${x}/${y}.txt` );
        req.send();
        	
        req.onload = function() {

            let row = req.responseText.split("\n");

            let mapData = new Array( TILE_SIZE );

            for(let i = 0; i < TILE_SIZE; i++) {
                mapData[i] = row[i].split(",");
            }
            
            const imageUrl = `https://cyberjapandata.gsi.go.jp/xyz/seamlessphoto/${z}/${x}/${y}.jpg`;

            drawMap( tileNum, mapData, imageUrl );
        }
    }


    function drawMap( tileNum, mapData, imageUrl ) {

        let geometry = new THREE.BufferGeometry();
        let vertices = [];
        let normals = [];
        let uvs = [];

        const dx = [[ 0, 1, 1 ], [ 0, 0, 1 ]], dy = [[ 0, 1, 0 ], [ 0, 1, 1 ]];

        // ((y * TILE_SIZE + x) * 2 + i) * 3 + j
        for(let y = 0; y < TILE_SIZE - 1; y++) {
            for(let x = 0; x < TILE_SIZE - 1; x++) {
                for(let i = 0; i < 2; i++) {
                    for(let j = 0; j < 3; j++) {

                        let z = mapData[ y + dy[i][j] ][ x + dx[i][j] ];
                        vertices.push( x + dx[i][j], y + dy[i][j], - z);
                        normals.push( 0, 0, 1 );
                        uvs.push( x / TILE_SIZE, 1 - y / TILE_SIZE );
                    }
                }
            }
        }

        geometry.setAttribute( "position", new THREE.Float32BufferAttribute( vertices, 3 ) );
        geometry.setAttribute( "normal", new THREE.Float32BufferAttribute( normals, 3 ) );
        geometry.setAttribute( "uv", new THREE.Float32BufferAttribute( uvs, 2 ) );
        geometry.computeVertexNormals ();

        const texture = new THREE.TextureLoader().load( imageUrl );
        const material = new THREE.MeshBasicMaterial({
            map: texture
        });

        const mesh = new THREE.Mesh( geometry, material );
        mesh.position.set( ( - 0.5 + t[tileNum].x ) * TILE_SIZE, 0, ( - 0.5 + t[tileNum].y ) * TILE_SIZE );
        mesh.rotation.set( 90 / 180 * Math.PI, 0, 0 );
        mesh.name = tileNum.toString();

        mapGroup.add( mesh );
    }

    function animate() {
        if ( controls ) {
            controls.update();
        }

        const c = { x: camera.position.x, y: camera.position.y, z: camera.position.z };

        renderer.render( scene, camera );
        requestAnimationFrame( animate );
    };

</script>
{% endblock %}