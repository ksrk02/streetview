{% extends "geomap/base.html" %}
{% load static %}

{% block content %}
<div id="status-window">
    <input id="zoom-level" type="number" placeholder="Zoom Level" value="14" min="5" max="18" step="1">
</div>

<script type="module">

    let elm = document.getElementById( "zoom-level" );
        
    elm.addEventListener( "change", function(e) {

        zoomLevel = elm.value;

        while(mapGroup.children.length > 0){ 
            mapGroup.remove( mapGroup.children[0] );
        }
        
        scene.remove( mapGroup );

        start();
        animate();
    });


    //three.js

    const TILE_SIZE = 256;
    const t = [
            { x: 0, y: 0 }, { x: 1, y: 0 }, { x: 1, y: 1 }, { x: 0, y: 1 }, { x: -1, y: 1 }, 
            { x: -1, y: 0 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }
        ];
    let zoomLevel = 14;

    let scene;
    let camera;
    let renderer;
    let controls;
    let mapDataList = new Array(9);
    let mapGroup = new THREE.Group();
    let location = { latitude: 34.686856, longtitude: 135.522961 };


    window.addEventListener("resize", function() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );
    }, false);


    window.addEventListener("load", function() {
        //getLocation();
        init();
        start();
        //updateVertices(0);
        animate();
    });




    function getLocation() {

        navigator.geolocation.getCurrentPosition(function( position ) {
            const lat = position.coords.latitude;
            const lng = position.coords.longitude;
            location = { latitude: lat, longtitude: lng };
        });
    }


    function init() {

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 1000 );
        camera.position.set(0, 800, 0);
        camera.lookAt(0, 0, 0);
        scene.add( camera );

        renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );
        
        document.body.appendChild( renderer.domElement );

        const axes = new THREE.AxesHelper( 600 );
        scene.add( axes );
        
        zoomLevel = document.getElementById("zoom-level").value;
        console.log(zoomLevel);

        setController();
    }


    function setController() {

        document.addEventListener("touchmove", function(e) { e.preventDefault(); }, { passive:false });

        controls = new THREE.OrbitControls( camera, renderer.domElement );

        controls.target.set( 0, 0, 0 );
        controls.enableDamping = true;
        controls.dampingFactor = 0.5;
        controls.enableZoom = true;
    }


    function start() {

        const tileCoordinate = getTileCoordinate( zoomLevel, location.latitude, location.longtitude );

        for(let i = 0; i < 9; i++) {
            const x = parseInt( tileCoordinate.x ) + t[i].x;
            const y = parseInt( tileCoordinate.y ) + t[i].y;
            loadData( i, zoomLevel, x, y );
        }

        scene.add( mapGroup );
    }


    function getTileCoordinate( z, lat, lng ) {

        const L = 85.05112878;
        const pixelCoordinate = {
            x: TILE_SIZE * Math.pow(2, z) * ( ( lng + 180 ) / 360 ),
            y: TILE_SIZE * Math.pow(2, z) / ( 2 * Math.PI ) * ( - Math.atanh( Math.sin( Math.PI / 180 * lat )) + Math.atanh( Math.sin( Math.PI / 180 * L ) ) )
        };

        const tileCoordinate = {
            x: pixelCoordinate.x / TILE_SIZE,
            y: pixelCoordinate.y / TILE_SIZE
        };

        return tileCoordinate;
    }


    function loadData( tileNum, z, x, y ) {

        let req = new XMLHttpRequest();
        req.open( "GET", `https://cyberjapandata.gsi.go.jp/xyz/dem/${z}/${x}/${y}.txt` );
        req.send();
        	
        req.onload = function() {

            let row = req.responseText.split("\n");

            mapDataList[tileNum] = new Array( TILE_SIZE + 1 );
            for(let i = 0; i < TILE_SIZE; i++) {
                row[i] += ",0";
                mapDataList[tileNum][i] = row[i].split(",");
            }
            mapDataList[tileNum][TILE_SIZE] = new Array( TILE_SIZE + 1 ).fill(0);
            
            const imageUrl = `https://cyberjapandata.gsi.go.jp/xyz/seamlessphoto/${z}/${x}/${y}.jpg`;
            drawMap( tileNum, mapDataList[tileNum], imageUrl );
        }
    }


    function drawMap( tileNum, mapData, imageUrl ) {

        let geometry = new THREE.BufferGeometry();
        let vertices = [];
        let normals = [];
        let uvs = [];
        const dx = [[ 0, 1, 1 ], [ 0, 0, 1 ]], dy = [[ 0, 1, 0 ], [ 0, 1, 1 ]];

        // ((y * TILE_SIZE + x) * 2 + i) * 3 + j
        for(let y = 0; y < TILE_SIZE; y++) {
            for(let x = 0; x < TILE_SIZE; x++) {
                for(let i = 0; i < 2; i++) {
                    for(let j = 0; j < 3; j++) {

                        let z = mapData[ y + dy[i][j] ][ x + dx[i][j] ];
                        vertices.push( x + dx[i][j], y + dy[i][j], - z * 0.5);
                        normals.push( 0, 0, 1 );
                        uvs.push( x / TILE_SIZE, 1 - y / TILE_SIZE );
                    }
                }
            }
        }

        geometry.setAttribute( "position", new THREE.Float32BufferAttribute( vertices, 3 ) );
        geometry.setAttribute( "normal", new THREE.Float32BufferAttribute( normals, 3 ) );
        geometry.setAttribute( "uv", new THREE.Float32BufferAttribute( uvs, 2 ) );
        geometry.computeVertexNormals ();

        const texture = new THREE.TextureLoader().load( imageUrl );
        const material = new THREE.MeshBasicMaterial({
            map: texture
        });

        const mesh = new THREE.Mesh( geometry, new THREE.MeshNormalMaterial() );
        mesh.position.set( ( - 0.5 + t[tileNum].x ) * TILE_SIZE, 0, ( - 0.5 + t[tileNum].y ) * TILE_SIZE );
        mesh.rotation.set( 90 / 180 * Math.PI, 0, 0 );
        mesh.name = tileNum.toString();

        mapGroup.add( mesh );


        updateVertices( tileNum );
        updateVertices( t.findIndex( function( v ) {
            return v.x == t[tileNum].x - 1 && v.y == t[tileNum].y;
        }));
        updateVertices( t.findIndex( function( v ) {
            return v.x == t[tileNum].x - 1 && v.y == t[tileNum].y - 1;
        }));
        updateVertices( t.findIndex( function( v ) {
            return v.x == t[tileNum].x && v.y == t[tileNum].y - 1;
        }));
    }


    function updateVertices( tileNum ) {
        if(tileNum == - 1) return;


        let arr = mapGroup.getObjectByName( tileNum.toString() ).geometry.attributes.position.array;

        let tileNum_1 = t.findIndex( function( v ) {
            return v.x == t[tileNum].x + 1 && v.y == t[tileNum].y;
        });
        let tileNum_2 = t.findIndex( function( v ) {
            return v.x == t[tileNum].x + 1 && v.y == t[tileNum].y + 1;
        });
        let tileNum_3 = t.findIndex( function( v ) {
            return v.x == t[tileNum].x && v.y == t[tileNum].y + 1;
        });


        if(mapDataList[tileNum_1]) {

            const i = [0, 1, 0], j = [1, 2, 2];

            for(let y = 0; y < TILE_SIZE; y++) {

                if(y > 0) {
                    arr[((((y - 1) * TILE_SIZE + TILE_SIZE - 1) * 2 + i[0]) * 3 + j[0]) * 3 + 2] = - mapDataList[tileNum_1][y][0];
                    arr[((((y - 1) * TILE_SIZE + TILE_SIZE - 1) * 2 + i[1]) * 3 + j[1]) * 3 + 2] = - mapDataList[tileNum_1][y][0];
                }

                arr[(((y * TILE_SIZE + TILE_SIZE - 1) * 2 + i[2]) * 3 + j[2]) * 3 + 2] = - mapDataList[tileNum_1][y][0];
            }
        }

        if(mapDataList[tileNum_2]) {

            const i = [0, 1], j = [1, 2];

            arr[((((TILE_SIZE - 1) * TILE_SIZE + TILE_SIZE - 1) * 2 + i[0]) * 3 + j[0]) * 3 + 2] = - mapDataList[tileNum_2][TILE_SIZE][0];
            arr[((((TILE_SIZE - 1) * TILE_SIZE + TILE_SIZE - 1) * 2 + i[1]) * 3 + j[1]) * 3 + 2] = - mapDataList[tileNum_2][TILE_SIZE][0];
        }

        if(mapDataList[tileNum_3]) {

            const i = [0, 1, 1], j = [1, 2, 1];

            for(let x = 0; x < TILE_SIZE; x++) {

                if(x > 0) {
                    arr[((((TILE_SIZE - 1) * TILE_SIZE + (x - 1)) * 2 + i[0]) * 3 + j[0]) * 3 + 2] = - mapDataList[tileNum_3][0][x];
                    arr[((((TILE_SIZE - 1) * TILE_SIZE + (x - 1)) * 2 + i[1]) * 3 + j[1]) * 3 + 2] = - mapDataList[tileNum_3][0][x];
                }

                arr[((((TILE_SIZE - 1) * TILE_SIZE + x) * 2 + i[2]) * 3 + j[2]) * 3 + 2] = - mapDataList[tileNum_3][0][x];
            }
        }
    }


    function animate() {
        if(controls){
            controls.update();
        }
        
        renderer.render( scene, camera );
        requestAnimationFrame( animate );
    };

</script>
{% endblock %}